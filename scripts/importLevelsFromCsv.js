// scripts/importLevelsFromCsv.js
// Usage:
//   node scripts/importLevelsFromCsv.js <csvFile> [--dry-run] [--fill-missing] [--repeat-missing]
//
// Supported CSV formats:
// - urdu_learning_platform_complete_50_units.csv (has `translation` column)
// - lessons_complete.csv (has `sentence_english` column + difficulty/theme metadata)
//
// What it does:
// - Reads the CSV
// - Groups rows by UNIT_XX
// - Upserts Level documents (levelNumber 1-50) with:
//   - words: [{urdu, english, romanUrdu}]
//   - sentences: [{urdu, englishTranslation}]
//   - passage: generated by concatenating a few example sentences
//   - metadata: unitId, difficultyLevel, targetAudience, grammarFocus, vocabularyTheme
// - Optionally fills missing levels up to 50:
//   - --fill-missing => placeholder lessons
//   - --repeat-missing => repeats parsed lessons in a loop (e.g. 1..10 repeated for 11..50)
//
// Notes:
// - MCQs in this app are generated from Level.words in views/lesson.ejs.

require('dotenv').config();

const fs = require('fs');
const path = require('path');

const connectDB = require('../config/db');
const Level = require('../models/Level');

function parseCsvLine(line) {
  // Minimal RFC4180-ish parser (handles commas inside quotes and escaped quotes)
  const out = [];
  let cur = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (inQuotes) {
      if (ch === '"') {
        // escaped quote
        if (line[i + 1] === '"') {
          cur += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        cur += ch;
      }
    } else {
      if (ch === ',') {
        out.push(cur);
        cur = '';
      } else if (ch === '"') {
        inQuotes = true;
      } else {
        cur += ch;
      }
    }
  }

  out.push(cur);
  return out;
}

function safeStr(v) {
  if (v === undefined || v === null) return '';
  return String(v).trim();
}

function unitIdToLevelNumber(unitId) {
  const m = /^UNIT_(\d{2})$/i.exec((unitId || '').trim());
  if (!m) return null;
  return Number(m[1]);
}

function uniqBy(arr, keyFn) {
  const seen = new Set();
  const out = [];
  for (const item of arr) {
    const k = keyFn(item);
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(item);
  }
  return out;
}

function placeholderLevel(levelNumber) {
  const baseWord = `لفظ_${levelNumber}`;
  const baseSentence = `یہ لیول ${levelNumber} کا جملہ ہے۔`;
  const basePassage = `یہ ایک لمبا اقتباس ہے۔ یہ لیول ${levelNumber} کے لیے کچھ اضافی مواد فراہم کرتا ہے۔`;

  return {
    levelNumber,
    title: `Lesson ${levelNumber} (Coming soon)`,
    unitId: `UNIT_${String(levelNumber).padStart(2, '0')}`,
    difficultyLevel: levelNumber <= 10 ? 'beginner' : levelNumber <= 30 ? 'intermediate' : 'advanced',
    targetAudience: '',
    grammarFocus: 'Coming soon',
    vocabularyTheme: 'Coming soon',
    isPlaceholder: true,
    words: [
      { urdu: baseWord, english: `Word ${levelNumber}`, romanUrdu: `Lafz ${levelNumber}` },
      { urdu: 'سلام', english: 'Hello/Peace', romanUrdu: 'Salam' },
      { urdu: 'شکریہ', english: 'Thank you', romanUrdu: 'Shukriya' }
    ],
    sentences: [
      { urdu: baseSentence, englishTranslation: `This is a sentence for Level ${levelNumber}.` },
      { urdu: 'میرا نام علی ہے۔', englishTranslation: 'My name is Ali.' }
    ],
    passage: {
      urdu: basePassage,
      englishTranslation: `This is the descriptive passage for Level ${levelNumber} designed for reading practice.`
    }
  };
}

function makeUnitId(levelNumber) {
  return `UNIT_${String(levelNumber).padStart(2, '0')}`;
}

function makeTitle(levelNumber, vocabularyTheme, grammarFocus) {
  const unitLabel = String(levelNumber).padStart(2, '0');
  const titleBits = [];
  if (vocabularyTheme) titleBits.push(vocabularyTheme);
  if (grammarFocus) titleBits.push(grammarFocus);
  return titleBits.length ? `Unit ${unitLabel}: ${titleBits.join(' • ')}` : `Unit ${unitLabel}`;
}

function deepClonePlain(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function cloneLevelFromTemplate(template, levelNumber) {
  const cloned = deepClonePlain(template);

  // Ensure identity fields match the new level
  cloned.levelNumber = levelNumber;
  cloned.unitId = makeUnitId(levelNumber);

  // Keep metadata, but rebuild the title so the unit number stays correct
  cloned.title = makeTitle(levelNumber, cloned.vocabularyTheme, cloned.grammarFocus);

  // These are *not* placeholders; they're repeated content from the CSV.
  cloned.isPlaceholder = false;

  return cloned;
}

async function importLevelsFromCsv({
  csvFile,
  dryRun = false,
  fillMissing = false,
  fillStrategy = 'placeholder',
  connect = true
} = {}) {
  if (!csvFile) {
    throw new Error('csvFile is required');
  }

  const csvPath = path.isAbsolute(csvFile) ? csvFile : path.join(process.cwd(), csvFile);
  if (!fs.existsSync(csvPath)) {
    throw new Error(`CSV not found: ${csvPath}`);
  }

  const raw = fs.readFileSync(csvPath, 'utf8');
  const lines = raw.split(/\r?\n/).filter((l) => l.trim().length > 0);

  if (lines.length < 2) {
    throw new Error('CSV appears empty or missing data rows.');
  }

  const header = parseCsvLine(lines[0]);
  const colIndex = new Map(header.map((h, i) => [h.trim(), i]));

  const requiredCols = ['unit_id', 'word_urdu', 'word_roman', 'meaning_eng', 'sentence_urdu'];
  const missingBase = requiredCols.filter((c) => !colIndex.has(c));
  if (missingBase.length) {
    throw new Error(`Missing required CSV columns: ${missingBase.join(', ')}`);
  }

  // Support either `translation` (old CSV) or `sentence_english` (lessons_complete.csv)
  const sentenceEnglishCol = colIndex.has('sentence_english')
    ? 'sentence_english'
    : colIndex.has('translation')
      ? 'translation'
      : null;

  if (!sentenceEnglishCol) {
    throw new Error('Missing required sentence English column: expected `sentence_english` or `translation`.');
  }

  const byLevel = new Map();

  for (let i = 1; i < lines.length; i++) {
    const row = parseCsvLine(lines[i]);
    if (row.length !== header.length) {
      // Skip malformed rows rather than crashing
      continue;
    }

    const unitId = safeStr(row[colIndex.get('unit_id')]);
    const levelNumber = unitIdToLevelNumber(unitId);
    if (!levelNumber) continue;

    const difficultyLevel = colIndex.has('difficulty_level') ? safeStr(row[colIndex.get('difficulty_level')]) : '';
    const targetAudience = colIndex.has('target_audience') ? safeStr(row[colIndex.get('target_audience')]) : '';
    const grammarFocus = colIndex.has('grammar_focus') ? safeStr(row[colIndex.get('grammar_focus')]) : '';
    const vocabularyTheme = colIndex.has('vocabulary_theme') ? safeStr(row[colIndex.get('vocabulary_theme')]) : '';

    const wordUrdu = safeStr(row[colIndex.get('word_urdu')]);
    const wordRoman = safeStr(row[colIndex.get('word_roman')]);
    const meaningEng = safeStr(row[colIndex.get('meaning_eng')]);

    const sentenceUrdu = safeStr(row[colIndex.get('sentence_urdu')]);
    const sentenceEng = safeStr(row[colIndex.get(sentenceEnglishCol)]);

    if (!byLevel.has(levelNumber)) {
      const unitLabel = String(levelNumber).padStart(2, '0');
      const titleBits = [];
      if (vocabularyTheme) titleBits.push(vocabularyTheme);
      if (grammarFocus) titleBits.push(grammarFocus);

      byLevel.set(levelNumber, {
        levelNumber,
        title: titleBits.length ? `Unit ${unitLabel}: ${titleBits.join(' • ')}` : `Unit ${unitLabel}`,
        unitId,
        difficultyLevel,
        targetAudience,
        grammarFocus,
        vocabularyTheme,
        isPlaceholder: false,
        words: [],
        sentences: []
      });
    }

    const acc = byLevel.get(levelNumber);

    if (wordUrdu && meaningEng) {
      acc.words.push({
        urdu: wordUrdu,
        english: meaningEng,
        romanUrdu: wordRoman
      });
    }

    if (sentenceUrdu && sentenceEng) {
      acc.sentences.push({
        urdu: sentenceUrdu,
        englishTranslation: sentenceEng
      });
    }
  }

  // Normalize + generate passage
  for (const acc of byLevel.values()) {
    acc.words = uniqBy(acc.words, (w) => w.urdu);
    acc.sentences = uniqBy(acc.sentences, (s) => s.urdu);

    const passageSentences = acc.sentences.slice(0, 4);
    const passageUrdu = passageSentences.map((s) => s.urdu).join(' ');
    const passageEng = passageSentences.map((s) => s.englishTranslation).join(' ');

    acc.passage = {
      urdu: passageUrdu || '—',
      englishTranslation: passageEng || '—'
    };
  }

  const parsedLevels = [...byLevel.keys()].sort((a, b) => a - b);
  console.log(`Parsed ${parsedLevels.length} levels from CSV.`);

  const wantsFill = fillMissing || parsedLevels.length < 50;
  const fillMode = String(fillStrategy || 'placeholder').toLowerCase();
  const allowed = new Set(['placeholder', 'repeat']);
  const mode = allowed.has(fillMode) ? fillMode : 'placeholder';

  if (wantsFill) {
    if (mode === 'repeat' && parsedLevels.length > 0) {
      const templates = parsedLevels.map((n) => byLevel.get(n)).filter(Boolean);

      for (let n = 1; n <= 50; n++) {
        if (byLevel.has(n)) continue;
        const tpl = templates[(n - 1) % templates.length];
        byLevel.set(n, cloneLevelFromTemplate(tpl, n));
      }
    } else {
      for (let n = 1; n <= 50; n++) {
        if (!byLevel.has(n)) byLevel.set(n, placeholderLevel(n));
      }
    }
  }

  const levels = [...byLevel.keys()].sort((a, b) => a - b);

  if (dryRun) {
    console.log('Dry run enabled; not writing to MongoDB.');
    console.log('Example level 1:', byLevel.get(1));
    console.log(`Total levels prepared: ${levels.length}`);
    return { dryRun: true, parsedLevels: parsedLevels.length, totalLevels: levels.length };
  }

  if (connect) {
    await connectDB();
  }

  let upserted = 0;
  for (const levelNumber of levels) {
    const data = byLevel.get(levelNumber);

    await Level.findOneAndUpdate(
      { levelNumber },
      {
        $set: {
          levelNumber,
          title: data.title,
          unitId: data.unitId || '',
          difficultyLevel: data.difficultyLevel || '',
          targetAudience: data.targetAudience || '',
          grammarFocus: data.grammarFocus || '',
          vocabularyTheme: data.vocabularyTheme || '',
          isPlaceholder: !!data.isPlaceholder,
          words: data.words,
          sentences: data.sentences,
          passage: data.passage
        }
      },
      { upsert: true, new: true, setDefaultsOnInsert: true }
    );

    upserted++;
  }

  console.log(`✅ Upserted ${upserted} Level documents.`);
  return { dryRun: false, parsedLevels: parsedLevels.length, totalLevels: levels.length, upserted };
}

module.exports = { importLevelsFromCsv };

async function main() {
  const args = process.argv.slice(2);
  const csvFile = args[0];
  const dryRun = args.includes('--dry-run');
  const repeatMissing = args.includes('--repeat-missing');
  const fillMissing = args.includes('--fill-missing') || repeatMissing;
  const fillStrategy = repeatMissing ? 'repeat' : 'placeholder';

  if (!csvFile) {
    console.error('Usage: node scripts/importLevelsFromCsv.js <csvFile> [--dry-run] [--fill-missing] [--repeat-missing]');
    process.exit(1);
  }

  try {
    await importLevelsFromCsv({ csvFile, dryRun, fillMissing, fillStrategy, connect: true });
    process.exit(0);
  } catch (err) {
    console.error('❌ Import failed:', err);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}
